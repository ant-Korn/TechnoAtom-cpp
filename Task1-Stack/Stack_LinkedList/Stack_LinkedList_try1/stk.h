//!@file stk.h
//! Заголовочный файл с описанием класса стека на основе связанного списка.
//!\brief Стек - это структура данных с методом доступа к элементам LIFO (last in — first out). 
//! В данном случае его реализации представлены в виде стеков на основе списка и на основе массива. 
//!
//! Класс стека на основе списка стека хранит в себе информацию о количестве элементов (элементы могут быть произвольного типа, но одного, передаваемого шаблону),
//! хранимых в данный момент в нём, а также указатель на верхний (последний занесённый) узел в нём. 
//! Узел же хранит информацию об одном из переданных элементов, а также указатель на следующий элемент в порядке: (последний переданный)->...->(первый переданный).
//!
//! Класс стека на основе массива хранит в себе информацию: о количестве элементов в стеке; указатель на динамический массив, в котором хранятся элементы стека; текущий размер динамического массива.
//!@author Корнилов Антон, 2017
//!@date 24.02.2017

#ifndef STK_LINKED_LIST_H
#define STK_LINKED_LIST_H

#include <iostream>
#include <iomanip>

#define new new( _NORMAL_BLOCK, __FILE__, __LINE__) //!< Макрос для вывода участка кода, в результате выполнения которого произошла утечка памяти средствами CRT.

#ifdef _MSC_VER
	#define FUNKNAME __FUNCSIG__ //!< Макрос для вывода имени текущей выполняемой функции, при компиляции в компиляторе MVS.
#else
	#define FUNKNAME __PRETTY_FUNCTION__ //!< Макрос для вывода имени текущей выполняемой функции, при компиляции в компиляторах, отличных от MVS.
#endif //_MSC_VER

//!Макрос проверки на пустоту стека. Если он не пуст, то кидается исключение с именем функции, в которой он был подставлен.
#define ASSERT_NOT_EMPTY() \
	if (empty()){     \
		dump();     \
		throw std::length_error("Error: Try to work with empty stack in: " FUNKNAME); \
	}	

//! \namespace stk В данном пространстве имён представлены описания и реализации классов стеков на основе связанного списка и на основе массива.
namespace stk{
	
	//!Класс, представляющий интерфейс для классов стеков.
	template <class T>
	class Stack_Interface{
	public:
		/*! Вывод полной информации о стеке.
		*/
		virtual void dump() const = 0;

		/*! Проверка на пустоту стека.
		\return Логическую переменную, которая говорит о том, является ли стек пустым или нет.
		*/
		virtual bool empty() const = 0;

		/*! Метод определения размера стека.
		\return Размер стека.
		*/
		virtual size_t size() const = 0;

		/*! Добавление элемента.
		\param[in] element Ссылка на элемент, информацию из которого необходимо хранить в стеке.
		*/
		virtual void push(const T& element) = 0;

		/*! Удаление узла с вершины стека.
		\throw length_error В случае, если стек оказался пустым.
		*/
		virtual void pop() = 0;

		/*! Доступ к верхнему элементу стека.
		\return Ссылку на хранимую информацию на вершине стека.
		\throw length_error В случае, если стек оказался пустым.
		*/
		virtual T& top() = 0;
	};

	

	//!Класс стека, реализованный на основе связного списка.
	template<class T>
	class StackAsList: public Stack_Interface<T>{
	public:
		/*! Конструктор стека на основе списка по умолчанию.
		*/
		StackAsList();

		/*!Метод обмена содержимым стеков на основе списка.
		\param[in] other_stack Стек, информацией с которым необходимо поменяться.
		*/
		void swap(StackAsList & other_stack);

		/*! Конструктор копирования стека на основе списка.
		\param[in] other_stack Стек, всю информацию из которого необходимо перенести в создаваемый.
		*/
		StackAsList(const StackAsList & other_stack);

		/*! Операция присваивания стека на основе списка.
		\param[in] other_stack Стек, всю информацию из которого необходимо перенести в текущий.
		\return Ссылку на текущий стек с перенесённой информацией.
		*/
		StackAsList & operator=(StackAsList other_stack);

		/*! Деструктор стека.
		*/
		~StackAsList();
		void dump() const;
		bool empty() const;
		size_t size() const;
		void push(const T&);
		void pop();
		T& top();
	private:
		//! Структура узла стека.
		//! \briefКаждый из узлов хранит занесёную в стек информацию, а также указатель на следующий узел.
		struct Node{
			T data_;	  //!< Хранит элемент, переданый в стек.
			Node * next_; //!< Указатель на следующий узел стека. Если данный узел последний, то равна nullptr.
			/*! Конструктор узла стека.
			\param[in] new_data Хранимая узлом информация.
			\param[in] next_node Указатель на следующий узел.
			*/
			Node(const T& new_data, Node * next_node = nullptr);
			/*! Деструктор узла стека
			*/
			~Node();
		};
		Node * top_;		//!< Хранит указатель на текущий элемент на вершине стека. Если элементов нет, то он равен nullptr.
		size_t num_items_;  //!< Хранит текущее количество узлов в стеке.
	};

	//!Класс стека, реализованный на основе динамического массива.
	template <class T>
	class StackAsMass: public Stack_Interface<T>{
	public:
		/*! Конструктор стека на основе массива по умолчанию.
		*/
		StackAsMass();

		/*! Конструктор стека на основе массива с заданием начального размера динамического массива.
		\param[in] capacity Начальный размер динамического массива.
		*/
		explicit StackAsMass(size_t capacity);

		/*!Метод обмена содержимым стеков на основе массива.
		\param[in] other_stack Стек, информацией с которым необходимо поменяться.
		*/
		void swap(StackAsMass & other_stack);

		/*! Конструктор копирования стека на основе массива.
		\param[in] other_stack Стек, всю информацию из которого необходимо перенести в создаваемый.
		*/
		StackAsMass(const StackAsMass & other_stack);

		/*! Операция присваивания стека на основе массива.
		\param[in] other_stack Стек, всю информацию из которого необходимо перенести в текущий.
		\return Ссылку на текущий стек с перенесённой информацией.
		*/
		StackAsMass & operator=(StackAsMass other_stack);

		/*! Деструктор стека на основе массива.
		*/
		~StackAsMass();
		void dump() const;
		bool empty() const;
		size_t size() const;
		void push(const T&);
		void pop();
		T& top();
	private:
		size_t capacity_;		//!<Размер массива, в котором хранятся данные стека.
		size_t num_items_;		//!<Количество хранимых элементов в стеке.
		T * data_;				//!<Указатель на массив хранящий данные стека в динамической памяти.
	};

#include "stk_as_list_realization.h"
#include "stk_as_mass_realization.h"

}

#endif //STK_LINKED_LIST_H