\hypertarget{namespacestk__test}{}\section{Пространство имен stk\+\_\+test}
\label{namespacestk__test}\index{stk\+\_\+test@{stk\+\_\+test}}


В данном пространстве имён представлены средства тестирования класса Stack.  


\subsection*{Перечисления}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78}{tests} \{ \\*
\hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a16992c4d9ecd605ea8503740aee9df96}{Push\+Single\+Number}, 
\hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a6e2bd84a1d3046f2c01c930a1d52be64}{Cannot\+Push\+More}, 
\hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78ae9c603d2f7d582fd4fdd5db8140ceecf}{Pop\+From\+Empty}, 
\hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78acd574f7057fc049aa4da1da5f4b7fd3a}{Top\+From\+Empty}, 
\\*
\hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78aef89859ac32f020e99414e3d3e559713}{Copy\+Stack}, 
\hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78adc3b2cd62978794a43af9212cd2c6be7}{Assignment\+Operator\+Of\+Stack}
 \}
\begin{DoxyCompactList}\small\item\em Доступные тесты. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Функции}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$template$<$ class Type\+\_\+of\+\_\+stack $>$ class T$>$ }\\void \hyperlink{namespacestk__test_a6e5c68f4363af9e5204334b3c875d641}{T\+E\+S\+T} (int test\+\_\+case)
\end{DoxyCompactItemize}


\subsection{Подробное описание}
В данном пространстве имён представлены средства тестирования класса Stack. 

\subsection{Перечисления}
\hypertarget{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78}{}\index{stk\+\_\+test@{stk\+\_\+test}!tests@{tests}}
\index{tests@{tests}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{tests}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf stk\+\_\+test\+::tests}}\label{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78}


Доступные тесты. 

\begin{Desc}
\item[Элементы перечислений]\par
\begin{description}
\index{Push\+Single\+Number@{Push\+Single\+Number}!stk\+\_\+test@{stk\+\_\+test}}\index{stk\+\_\+test@{stk\+\_\+test}!Push\+Single\+Number@{Push\+Single\+Number}}\item[{\em 
\hypertarget{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a16992c4d9ecd605ea8503740aee9df96}{}Push\+Single\+Number\label{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a16992c4d9ecd605ea8503740aee9df96}
}]Тестирование на верное добавление одного элемента в стек переменных int. \index{Cannot\+Push\+More@{Cannot\+Push\+More}!stk\+\_\+test@{stk\+\_\+test}}\index{stk\+\_\+test@{stk\+\_\+test}!Cannot\+Push\+More@{Cannot\+Push\+More}}\item[{\em 
\hypertarget{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a6e2bd84a1d3046f2c01c930a1d52be64}{}Cannot\+Push\+More\label{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a6e2bd84a1d3046f2c01c930a1d52be64}
}]Тестирование на добавление элементов такого количества элементов, память под которые не может быть выделена под 32-\/битный процесс. \index{Pop\+From\+Empty@{Pop\+From\+Empty}!stk\+\_\+test@{stk\+\_\+test}}\index{stk\+\_\+test@{stk\+\_\+test}!Pop\+From\+Empty@{Pop\+From\+Empty}}\item[{\em 
\hypertarget{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78ae9c603d2f7d582fd4fdd5db8140ceecf}{}Pop\+From\+Empty\label{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78ae9c603d2f7d582fd4fdd5db8140ceecf}
}]Тестирование на удаление узла из пустого стека. \index{Top\+From\+Empty@{Top\+From\+Empty}!stk\+\_\+test@{stk\+\_\+test}}\index{stk\+\_\+test@{stk\+\_\+test}!Top\+From\+Empty@{Top\+From\+Empty}}\item[{\em 
\hypertarget{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78acd574f7057fc049aa4da1da5f4b7fd3a}{}Top\+From\+Empty\label{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78acd574f7057fc049aa4da1da5f4b7fd3a}
}]Тестирование на получение ссылки из пустого стека. \index{Copy\+Stack@{Copy\+Stack}!stk\+\_\+test@{stk\+\_\+test}}\index{stk\+\_\+test@{stk\+\_\+test}!Copy\+Stack@{Copy\+Stack}}\item[{\em 
\hypertarget{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78aef89859ac32f020e99414e3d3e559713}{}Copy\+Stack\label{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78aef89859ac32f020e99414e3d3e559713}
}]Тестирование на правильную работу конструктора копирования. \index{Assignment\+Operator\+Of\+Stack@{Assignment\+Operator\+Of\+Stack}!stk\+\_\+test@{stk\+\_\+test}}\index{stk\+\_\+test@{stk\+\_\+test}!Assignment\+Operator\+Of\+Stack@{Assignment\+Operator\+Of\+Stack}}\item[{\em 
\hypertarget{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78adc3b2cd62978794a43af9212cd2c6be7}{}Assignment\+Operator\+Of\+Stack\label{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78adc3b2cd62978794a43af9212cd2c6be7}
}]Тестирование на правильную работу операции присваивания. \end{description}
\end{Desc}

\begin{DoxyCode}
42                \{ \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a16992c4d9ecd605ea8503740aee9df96}{PushSingleNumber},
43         \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a6e2bd84a1d3046f2c01c930a1d52be64}{CannotPushMore},
44         \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78ae9c603d2f7d582fd4fdd5db8140ceecf}{PopFromEmpty},
45         \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78acd574f7057fc049aa4da1da5f4b7fd3a}{TopFromEmpty},
46         \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78aef89859ac32f020e99414e3d3e559713}{CopyStack},
47         \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78adc3b2cd62978794a43af9212cd2c6be7}{AssignmentOperatorOfStack}
48     \};
\end{DoxyCode}


\subsection{Функции}
\hypertarget{namespacestk__test_a6e5c68f4363af9e5204334b3c875d641}{}\index{stk\+\_\+test@{stk\+\_\+test}!T\+E\+S\+T@{T\+E\+S\+T}}
\index{T\+E\+S\+T@{T\+E\+S\+T}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{T\+E\+S\+T}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class Type\+\_\+of\+\_\+stack $>$ class T$>$ void stk\+\_\+test\+::\+T\+E\+S\+T (
\begin{DoxyParamCaption}
\item[{int}]{test\+\_\+case}
\end{DoxyParamCaption}
)}\label{namespacestk__test_a6e5c68f4363af9e5204334b3c875d641}

\begin{DoxyParams}[1]{Аргументы}
\mbox{\tt in}  & {\em test\+\_\+case} & Идентификатор одного из предлагаемых тестов. \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
58                             \{
59         \textcolor{keywordflow}{switch}(test\_case)\{                                                    
60             \textcolor{keywordflow}{case} \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a16992c4d9ecd605ea8503740aee9df96}{PushSingleNumber}:  \{                                        
61                 T<int> s\_i;                                                 
62                 \textcolor{keywordflow}{try}\{                                                                                                
63                     s\_i.push(3802);                                         
64                     ASSERT\_EQ(s\_i.top() == 0xEDA);
65                     s\_i.pop();
66                     ASSERT\_EQ(s\_i.size() == 0);
67                     ASSERT\_EQ(s\_i.empty());
68                     std::cout << \textcolor{stringliteral}{"Test is successfully completed!"} << std::endl;
69                 \}                                                               
70                 \textcolor{keywordflow}{catch}(std::exception & ex)\{                                                
71                     std::cout << ex.what() << std::endl;
72                     s\_i.dump();
73                 \} 
74                                     \}                                                           
75                 \textcolor{keywordflow}{break}; 
76             \textcolor{keywordflow}{case} \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78a6e2bd84a1d3046f2c01c930a1d52be64}{CannotPushMore}:\{ \textcolor{comment}{/*< При проведении данного теста программа даёт "runtime
       error", так как пытается выделить под стек больше памяти, чем позволено 32-битному процессу,}
77 \textcolor{comment}{                                   ввиду ограничения размера стека только доступной памятью                                                                                     
       }
78 \textcolor{comment}{                                   Для ускорения теста требуется отключить проверку ASSERT\_OK() в методе
       push.*/}
79                 T<int> s\_i; 
80                 \textcolor{keywordtype}{int} value = 1;
81                 \textcolor{keywordflow}{try}\{
82                     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < SIZE\_MAX; ++i)\{
83                         s\_i.push(value);
84                     \}
85                 \}
86                 \textcolor{keywordflow}{catch}(std::bad\_alloc & ex)\{
87                     std::cout << \textcolor{stringliteral}{"Error: bad alloc caught!"}<< ex.what() << std::endl;
88                     s\_i.dump(); 
89                 \}
90                 \textcolor{keywordflow}{catch}(std::exception & ex)\{
91                     std::cout << ex.what() << std::endl;
92                 \}
93                                 \}
94                 \textcolor{keywordflow}{break};
95             \textcolor{keywordflow}{case} \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78ae9c603d2f7d582fd4fdd5db8140ceecf}{PopFromEmpty}:\{
96                 T<int> s\_i;
97                 \textcolor{keywordflow}{try}\{
98                     ASSERT\_EQ(s\_i.size() == 0);
99                     s\_i.pop();
100                 \}
101                 \textcolor{keywordflow}{catch}(std::exception & ex)\{
102                     std::cout << ex.what() << std::endl;
103                     std::cout << \textcolor{stringliteral}{"Test is successfully completed!"} << std::endl;
104                 \}
105                               \}
106                 \textcolor{keywordflow}{break};
107             \textcolor{keywordflow}{case} \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78acd574f7057fc049aa4da1da5f4b7fd3a}{TopFromEmpty}:\{
108                 T<int> s\_i;
109                 \textcolor{keywordflow}{try}\{
110                     ASSERT\_EQ(s\_i.size() == 0);
111                     \textcolor{keywordtype}{int} var = s\_i.top();
112                     std::cout << \textcolor{stringliteral}{"Top variable = "} << var << std::endl;
113                 \}
114                 \textcolor{keywordflow}{catch}(std::exception & ex)\{
115                     std::cout << ex.what() << std::endl;
116                     std::cout << \textcolor{stringliteral}{"Test is successfully completed!"} << std::endl;
117                 \}
118                               \}
119                 \textcolor{keywordflow}{break};
120             \textcolor{keywordflow}{case} \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78aef89859ac32f020e99414e3d3e559713}{CopyStack}:\{
121                 \textcolor{keyword}{auto} num\_of\_elements = 5;
122                 T<int> s\_i1;
123                 \textcolor{keywordflow}{try}\{
124                     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0;i<num\_of\_elements;++i)\{
125                         s\_i1.push(i);
126                     \}
127                 \}
128                 \textcolor{keywordflow}{catch}(std::exception & ex)\{
129                     std::cout << ex.what() << std::endl;
130                     s\_i1.dump();
131                 \}
132                 T<int> s\_i2(s\_i1);
133                 \textcolor{keywordflow}{try}\{
134                     ASSERT\_EQ(s\_i1.size() == s\_i2.size());
135                     \textcolor{keywordflow}{while}(s\_i2.size())\{
136                         ASSERT\_EQ(s\_i1.top() == s\_i2.top());   \textcolor{comment}{//Сравнение значений в узлах стеков}
137                         ASSERT\_EQ(&s\_i1.top() != &s\_i2.top()); \textcolor{comment}{//Сравнение адресов узлов стека}
138                         s\_i1.pop();
139                         s\_i2.pop();
140                     \}
141                     ASSERT\_EQ(s\_i1.empty());
142                     std::cout << \textcolor{stringliteral}{"Test is successfully completed!"} << std::endl;
143                 \}
144                 \textcolor{keywordflow}{catch}(std::exception & ex)\{
145                     std::cout << ex.what() << std::endl;
146                     s\_i1.dump();
147                     s\_i2.dump();
148                 \}
149                               \}
150                 \textcolor{keywordflow}{break};
151             \textcolor{keywordflow}{case} \hyperlink{namespacestk__test_aee7ec7a767abf7b0b65ce9a2afb7de78adc3b2cd62978794a43af9212cd2c6be7}{AssignmentOperatorOfStack}:\{
152                 \textcolor{keyword}{auto} num\_of\_elements1 = 5;
153                 \textcolor{keyword}{auto} num\_of\_elements2 = 3;
154                 T<int> s\_i1;
155                 \textcolor{keywordflow}{try}\{
156                     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0;i<num\_of\_elements1;++i)\{
157                         s\_i1.push(i);
158                     \}
159                 \}
160                 \textcolor{keywordflow}{catch}(std::exception & ex)\{
161                     std::cout << ex.what() << std::endl;
162                     s\_i1.dump();
163                 \}
164                 T<int> s\_i2;
165                 \textcolor{keywordflow}{try}\{
166                     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0;i<num\_of\_elements2;++i)\{
167                         s\_i2.push(i);
168                     \}
169                     s\_i2 = s\_i1;                               \textcolor{comment}{//Операция присваивания}
170                     ASSERT\_EQ(s\_i1.size() == s\_i2.size());
171                     \textcolor{keywordflow}{while}(s\_i2.size())\{
172                         ASSERT\_EQ(s\_i1.top() == s\_i2.top());   \textcolor{comment}{//Сравнение значений стеков}
173                         ASSERT\_EQ(&s\_i1.top() != &s\_i2.top()); \textcolor{comment}{//Сравнение адресов узлов стека}
174                         s\_i1.pop();
175                         s\_i2.pop();
176                     \}
177                     ASSERT\_EQ(s\_i1.empty());
178                     std::cout << \textcolor{stringliteral}{"Test is successfully completed!"} << std::endl;
179                 \}
180                 \textcolor{keywordflow}{catch}(std::exception & ex)\{
181                     std::cout << ex.what() << std::endl;
182                     s\_i1.dump();
183                     s\_i2.dump();
184                 \}
185                                            \}
186                 \textcolor{keywordflow}{break};
187             \textcolor{keywordflow}{default}: std::cout << \textcolor{stringliteral}{"Error: Don't have such test!"} << std::endl; \textcolor{keywordflow}{break}; 
188         \}
189     \}
\end{DoxyCode}
