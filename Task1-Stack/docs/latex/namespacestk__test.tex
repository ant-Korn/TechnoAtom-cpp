\hypertarget{namespacestk__test}{}\section{Пространство имен stk\+\_\+test}
\label{namespacestk__test}\index{stk\+\_\+test@{stk\+\_\+test}}


В данном пространстве имён представлены средства тестирования классов Stack\+As\+List и Stack\+As\+Mass.  


\subsection*{Функции}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_a2d62ae6019345309a38d3a15ff28cc5d}{Test\+Push} ()
\begin{DoxyCompactList}\small\item\em Тестирование на верное добавление одного элемента в стек. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_a359fc261443d7bdcd4d9bfa43ce9dc7d}{Test\+Pop} ()
\begin{DoxyCompactList}\small\item\em Тестирование на удаление элемента с вершины стека. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_aadcc1a403c31c6f26df731492b32bb5e}{Test\+Top} ()
\begin{DoxyCompactList}\small\item\em Тестирование на получение ссылки на верхний элемент. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_aa0039c601a4cf946ebfaad9ef3af4e7f}{Test\+Copy\+Constructor} ()
\begin{DoxyCompactList}\small\item\em Тестирование на правильную работу конструктора копирования. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_a3ba77d093637ee2f396e752cea61aee0}{Test\+Assignment\+Operator} ()
\begin{DoxyCompactList}\small\item\em Тестирование на правильную работу операции присваивания. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_a7c74f2910436ae4560d47bd088fa414c}{Test\+Empty} ()
\begin{DoxyCompactList}\small\item\em Тестирование проверки стека на пустоту. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_a24faf9dd70ba3d62af3a455dd9437090}{Test\+Size} ()
\begin{DoxyCompactList}\small\item\em Тестирование получения размера стека. \end{DoxyCompactList}\item 
{\footnotesize template$<$template$<$ class T $>$ class Stack\+Type$>$ }\\void \hyperlink{namespacestk__test_af617996279c5a7955ab644d545de7efc}{Test\+Swap} ()
\begin{DoxyCompactList}\small\item\em Тестирование обмена содержимым стеков. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Подробное описание}
В данном пространстве имён представлены средства тестирования классов Stack\+As\+List и Stack\+As\+Mass. 

\subsection{Функции}
\hypertarget{namespacestk__test_a3ba77d093637ee2f396e752cea61aee0}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Assignment\+Operator@{Test\+Assignment\+Operator}}
\index{Test\+Assignment\+Operator@{Test\+Assignment\+Operator}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Assignment\+Operator}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Assignment\+Operator (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_a3ba77d093637ee2f396e752cea61aee0}


Тестирование на правильную работу операции присваивания. 

Given\+: Два стека типа int, заполненных разными известными количествомами элементов. When\+: Совершаем присваивание второму стеку первого, проверяем что размеры данных массивов совпадают, последовательно проверяем, что элементы данных стеков, находящиеся на равной глубине имеют одинаковые данные, но хранятся по разным адресам в памяти. Then\+: Все проверки и действия успешно завершаются без вызова исключений. 
\begin{DoxyCode}
172                                  \{
173         \textcolor{keyword}{auto} num\_of\_elements1 = 5;
174         \textcolor{keyword}{auto} num\_of\_elements2 = 3;
175         StackType<int> s\_i1;
176         \textcolor{keywordflow}{try}\{
177             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0;i<num\_of\_elements1;++i)\{
178                 s\_i1.push(i);
179             \}
180         \}
181         \textcolor{keywordflow}{catch}(std::exception & ex)\{
182             std::cout << ex.what() << std::endl;
183             s\_i1.dump();
184         \}
185         StackType<int> s\_i2;
186         \textcolor{keywordflow}{try}\{
187             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0;i<num\_of\_elements2;++i)\{
188                 s\_i2.push(i);
189             \}
190             s\_i2 = s\_i1;                               
191             ASSERT\_TRUE(s\_i1.size() == s\_i2.size());
192             \textcolor{keywordflow}{while}(s\_i2.size())\{
193                 ASSERT\_TRUE(s\_i1.top() == s\_i2.top());  
194                 ASSERT\_TRUE(&s\_i1.top() != &s\_i2.top()); 
195                 s\_i1.pop();
196                 s\_i2.pop();
197             \}
198             ASSERT\_TRUE(s\_i1.empty());
199             TEST\_PASSED();
200         \}
201         \textcolor{keywordflow}{catch}(std::exception & ex)\{
202             std::cout << ex.what() << std::endl;
203             s\_i1.dump();
204             s\_i2.dump();
205             TEST\_FAILED();
206         \}
207     \}
\end{DoxyCode}
\hypertarget{namespacestk__test_aa0039c601a4cf946ebfaad9ef3af4e7f}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Copy\+Constructor@{Test\+Copy\+Constructor}}
\index{Test\+Copy\+Constructor@{Test\+Copy\+Constructor}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Copy\+Constructor}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Copy\+Constructor (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_aa0039c601a4cf946ebfaad9ef3af4e7f}


Тестирование на правильную работу конструктора копирования. 

Given\+: Стек типа int, заполненный известным количеством элементов. When\+: Создаём новый стек на основе первого при помощи конструктора копирования, проверяем что размеры данных массивов совпадают, последовательно проверяем, что элементы данных стеков, находящиеся на равной глубине имеют одинаковые данные, но хранятся по разным адресам в памяти. Then\+: Все проверки и действия успешно завершаются без вызова исключений. 
\begin{DoxyCode}
133                               \{
134         \textcolor{keyword}{auto} num\_of\_elements = 5;
135         StackType<int> s\_i1;
136         \textcolor{keywordflow}{try}\{
137             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0;i<num\_of\_elements;++i)\{
138                 s\_i1.push(i);
139             \}
140         \}
141         \textcolor{keywordflow}{catch}(std::exception & ex)\{
142             std::cout << ex.what() << std::endl;
143             s\_i1.dump();
144         \}
145         StackType<int> s\_i2(s\_i1);
146         \textcolor{keywordflow}{try}\{
147             ASSERT\_TRUE(s\_i1.size() == s\_i2.size());
148             \textcolor{keywordflow}{while}(s\_i2.size())\{
149                 ASSERT\_TRUE(s\_i1.top() == s\_i2.top());   
150                 ASSERT\_TRUE(&s\_i1.top() != &s\_i2.top()); 
151                 s\_i1.pop();
152                 s\_i2.pop();
153             \}
154             ASSERT\_TRUE(s\_i1.empty());
155             TEST\_PASSED();
156         \}
157         \textcolor{keywordflow}{catch}(std::exception & ex)\{
158             std::cout << ex.what() << std::endl;
159             s\_i1.dump();
160             s\_i2.dump();
161             TEST\_FAILED();
162         \}
163     \}
\end{DoxyCode}
\hypertarget{namespacestk__test_a7c74f2910436ae4560d47bd088fa414c}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Empty@{Test\+Empty}}
\index{Test\+Empty@{Test\+Empty}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Empty}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_a7c74f2910436ae4560d47bd088fa414c}


Тестирование проверки стека на пустоту. 

Given\+: Пустой стек типа int. When\+: Проверяем стек на пустоту, кладём в стек один элемент типа int, проверяем что стек не пустой. Then\+: Все проиходящие проверки успешно завершаются без вызова исключений. 
\begin{DoxyCode}
215                     \{
216         StackType<int> s\_i;
217         \textcolor{keyword}{const} \textcolor{keywordtype}{int} push\_num = 1;
218         \textcolor{keywordflow}{try}\{
219             ASSERT\_TRUE(s\_i.empty());
220             s\_i.push(push\_num);
221             ASSERT\_TRUE(!s\_i.empty());
222             TEST\_PASSED();
223         \}
224         \textcolor{keywordflow}{catch}(std::exception & ex)\{
225             std::cout << ex.what() << std::endl;
226             s\_i.dump();
227             TEST\_FAILED();
228         \}
229     \}
\end{DoxyCode}
\hypertarget{namespacestk__test_a359fc261443d7bdcd4d9bfa43ce9dc7d}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Pop@{Test\+Pop}}
\index{Test\+Pop@{Test\+Pop}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Pop}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Pop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_a359fc261443d7bdcd4d9bfa43ce9dc7d}


Тестирование на удаление элемента с вершины стека. 

Given\+: Стек типа int с одним хранимым значением. When\+: Удаляем из стека один элемент, проверяем стек на пустоту, удаляем из стека ещё один элемент. Then\+: Проверка на пустоту стека успешно завершается, но при последующем удалении элемента вызывается исключение с сообщением о работе с пустым стеком и выводится его содержимое. 
\begin{DoxyCode}
83                   \{
84         StackType<int> s\_i;
85         \textcolor{keyword}{const} \textcolor{keywordtype}{int} value = 1;
86         \textcolor{keywordflow}{try}\{
87             s\_i.push(value);
88             s\_i.pop();
89             ASSERT\_TRUE(s\_i.size() == 0);
90             s\_i.pop();
91             TEST\_FAILED();
92             s\_i.dump();
93         \}
94         \textcolor{keywordflow}{catch}(std::exception & ex)\{
95             std::cout << ex.what() << std::endl;
96             TEST\_PASSED();
97         \}
98     \}
\end{DoxyCode}
\hypertarget{namespacestk__test_a2d62ae6019345309a38d3a15ff28cc5d}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Push@{Test\+Push}}
\index{Test\+Push@{Test\+Push}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Push}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Push (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_a2d62ae6019345309a38d3a15ff28cc5d}


Тестирование на верное добавление одного элемента в стек. 

Given\+: Пустой стек типа int. When\+: Кладём в стек число 3802, сравниваем число на вершине стека с числом 0x\+E\+D\+A, удаляем из стека один элемент, проверяем стек на пустоту. Then\+: Все действия со стеком и проиходящие проверки успешно завершаются без вызова исключений. 
\begin{DoxyCode}
60                    \{
61         StackType<int> s\_i;                                                 
62         \textcolor{keywordflow}{try}\{                                                                                                
63             s\_i.push(3802);                                         
64             ASSERT\_TRUE(s\_i.top() == 0xEDA);
65             s\_i.pop();
66             ASSERT\_TRUE(s\_i.size() == 0);
67             ASSERT\_TRUE(s\_i.empty());
68             TEST\_PASSED();
69         \}                                                               
70         \textcolor{keywordflow}{catch}(std::exception & ex)\{   
71             std::cout << ex.what() << std::endl;
72             s\_i.dump();
73             TEST\_FAILED();
74         \} 
75     \}
\end{DoxyCode}
\hypertarget{namespacestk__test_a24faf9dd70ba3d62af3a455dd9437090}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Size@{Test\+Size}}
\index{Test\+Size@{Test\+Size}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Size}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_a24faf9dd70ba3d62af3a455dd9437090}


Тестирование получения размера стека. 

Given\+: Пустой стек типа int, количество элементов для заполнения. When\+: Получаем размер стека и сравниваем его с нулём, кладём в стек данное количество элементов типа int, получаем размер стека и сравниваем его с известным количеством элементов. Then\+: Все проиходящие проверки успешно завершаются без вызова исключений. 
\begin{DoxyCode}
237                    \{
238         StackType<int> s\_i;
239         \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_of\_elements = 3;
240         \textcolor{keywordflow}{try}\{
241             ASSERT\_TRUE(s\_i.size()==0);
242             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0; i<num\_of\_elements; ++i)\{
243                 s\_i.push(i);
244             \}
245             ASSERT\_TRUE(s\_i.size()==num\_of\_elements);
246             TEST\_PASSED();
247         \}
248         \textcolor{keywordflow}{catch}(std::exception & ex)\{
249             std::cout << ex.what() << std::endl;
250             s\_i.dump();
251             TEST\_FAILED();
252         \}
253     \}
\end{DoxyCode}
\hypertarget{namespacestk__test_af617996279c5a7955ab644d545de7efc}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Swap@{Test\+Swap}}
\index{Test\+Swap@{Test\+Swap}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Swap}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Swap (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_af617996279c5a7955ab644d545de7efc}


Тестирование обмена содержимым стеков. 

Given\+: Два стека типа int, заполненных разными известными количествомами известных элементов. When\+: Вызываем метод обмена элементами стеков, проверяем, что размеры стеков взаимно поменялись, а также то, что они взаимно обменялись элементами, находящимися на соответствующей глубине. Then\+: Все проверки и действия успешно завершаются без вызова исключений. 
\begin{DoxyCode}
261                    \{
262         StackType<int> s\_i1, s\_i2;
263         \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_of\_elements1 = 3, num\_of\_elements2 = 5;
264         \textcolor{keywordflow}{try}\{
265             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0; i<num\_of\_elements1; ++i)\{
266                 s\_i1.push(i);
267             \}
268             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=0; i<num\_of\_elements2; ++i)\{
269                 s\_i2.push(i);
270             \}
271 
272             s\_i1.swap(s\_i2);
273 
274             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=(num\_of\_elements2-1); i>=0; --i)\{
275                 ASSERT\_TRUE(s\_i1.top()==i);
276                 s\_i1.pop();
277             \}
278             ASSERT\_TRUE(s\_i1.empty());
279 
280             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i=(num\_of\_elements1-1); i>=0; --i)\{
281                 ASSERT\_TRUE(s\_i2.top()==i);
282                 s\_i2.pop();
283             \}
284             ASSERT\_TRUE(s\_i2.empty());
285 
286             TEST\_PASSED();
287         \}
288         \textcolor{keywordflow}{catch}(std::exception & ex)\{
289             std::cout << ex.what() << std::endl;
290             s\_i1.dump();
291             s\_i2.dump();
292             TEST\_FAILED();
293         \}
294     \}
\end{DoxyCode}
\hypertarget{namespacestk__test_aadcc1a403c31c6f26df731492b32bb5e}{}\index{stk\+\_\+test@{stk\+\_\+test}!Test\+Top@{Test\+Top}}
\index{Test\+Top@{Test\+Top}!stk\+\_\+test@{stk\+\_\+test}}
\subsubsection[{Test\+Top}]{\setlength{\rightskip}{0pt plus 5cm}template$<$template$<$ class T $>$ class Stack\+Type$>$ void stk\+\_\+test\+::\+Test\+Top (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespacestk__test_aadcc1a403c31c6f26df731492b32bb5e}


Тестирование на получение ссылки на верхний элемент. 

Given\+: Стек типа int с одним хранимым известным значением. When\+: Получаем ссылку на верхний элемент и сравниваем его с известным значением, удаляем из стека один элемент, проверяем стек на пустоту, получаем ссылку на следующий верхний элемент и выводим её содержимое. Then\+: Все действия и проверки успешно завершаются, кроме последнего получения ссылки на верхний элемент, при этом вызывается исключение с сообщением о работе с пустым стеком и выводится его содержимое. 
\begin{DoxyCode}
107                   \{
108         StackType<int> s\_i;
109         \textcolor{keyword}{const} \textcolor{keywordtype}{int} value = 1;
110         \textcolor{keywordflow}{try}\{
111             s\_i.push(value);
112             ASSERT\_TRUE(s\_i.top() == 1);
113             s\_i.pop();
114             ASSERT\_TRUE(s\_i.size() == 0);
115             \textcolor{keywordtype}{int} var = s\_i.top();
116             std::cout << \textcolor{stringliteral}{"Top variable = "} << var << std::endl;
117             TEST\_FAILED();
118             s\_i.dump();
119         \}
120         \textcolor{keywordflow}{catch}(std::exception & ex)\{
121             std::cout << ex.what() << std::endl;
122             TEST\_PASSED();
123         \}
124     \}
\end{DoxyCode}
